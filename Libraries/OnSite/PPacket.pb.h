// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: PPacket.proto

#ifndef PROTOBUF_PPacket_2eproto__INCLUDED
#define PROTOBUF_PPacket_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace OnSite {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_PPacket_2eproto();
void protobuf_AssignDesc_PPacket_2eproto();
void protobuf_ShutdownFile_PPacket_2eproto();

class PUpdateLuaString;
class PUpdateLuaBoolean;
class PUpdateLuaNumber;
class PUpdate;
class PFilePart;
class PControl;
class PPacket;

enum PUpdateType {
  PUT_NUMBER = 0,
  PUT_STRING = 1,
  PUT_BOOL = 2
};
bool PUpdateType_IsValid(int value);
const PUpdateType PUpdateType_MIN = PUT_NUMBER;
const PUpdateType PUpdateType_MAX = PUT_BOOL;
const int PUpdateType_ARRAYSIZE = PUpdateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PUpdateType_descriptor();
inline const ::std::string& PUpdateType_Name(PUpdateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PUpdateType_descriptor(), value);
}
inline bool PUpdateType_Parse(
    const ::std::string& name, PUpdateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PUpdateType>(
    PUpdateType_descriptor(), name, value);
}
enum PPacketType {
  PPT_UPDATE = 0,
  PPT_FILE = 1,
  PPT_CONTROL = 2
};
bool PPacketType_IsValid(int value);
const PPacketType PPacketType_MIN = PPT_UPDATE;
const PPacketType PPacketType_MAX = PPT_CONTROL;
const int PPacketType_ARRAYSIZE = PPacketType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PPacketType_descriptor();
inline const ::std::string& PPacketType_Name(PPacketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PPacketType_descriptor(), value);
}
inline bool PPacketType_Parse(
    const ::std::string& name, PPacketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PPacketType>(
    PPacketType_descriptor(), name, value);
}
enum PControlType {
  PCT_TEST = 0,
  PCT_TEST2 = 1
};
bool PControlType_IsValid(int value);
const PControlType PControlType_MIN = PCT_TEST;
const PControlType PControlType_MAX = PCT_TEST2;
const int PControlType_ARRAYSIZE = PControlType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PControlType_descriptor();
inline const ::std::string& PControlType_Name(PControlType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PControlType_descriptor(), value);
}
inline bool PControlType_Parse(
    const ::std::string& name, PControlType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PControlType>(
    PControlType_descriptor(), name, value);
}
// ===================================================================

class PUpdateLuaString : public ::google::protobuf::Message {
 public:
  PUpdateLuaString();
  virtual ~PUpdateLuaString();

  PUpdateLuaString(const PUpdateLuaString& from);

  inline PUpdateLuaString& operator=(const PUpdateLuaString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PUpdateLuaString& default_instance();

  void Swap(PUpdateLuaString* other);

  // implements Message ----------------------------------------------

  PUpdateLuaString* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PUpdateLuaString& from);
  void MergeFrom(const PUpdateLuaString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:OnSite.PUpdateLuaString)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PPacket_2eproto();
  friend void protobuf_AssignDesc_PPacket_2eproto();
  friend void protobuf_ShutdownFile_PPacket_2eproto();

  void InitAsDefaultInstance();
  static PUpdateLuaString* default_instance_;
};
// -------------------------------------------------------------------

class PUpdateLuaBoolean : public ::google::protobuf::Message {
 public:
  PUpdateLuaBoolean();
  virtual ~PUpdateLuaBoolean();

  PUpdateLuaBoolean(const PUpdateLuaBoolean& from);

  inline PUpdateLuaBoolean& operator=(const PUpdateLuaBoolean& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PUpdateLuaBoolean& default_instance();

  void Swap(PUpdateLuaBoolean* other);

  // implements Message ----------------------------------------------

  PUpdateLuaBoolean* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PUpdateLuaBoolean& from);
  void MergeFrom(const PUpdateLuaBoolean& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline bool value() const;
  inline void set_value(bool value);

  // @@protoc_insertion_point(class_scope:OnSite.PUpdateLuaBoolean)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PPacket_2eproto();
  friend void protobuf_AssignDesc_PPacket_2eproto();
  friend void protobuf_ShutdownFile_PPacket_2eproto();

  void InitAsDefaultInstance();
  static PUpdateLuaBoolean* default_instance_;
};
// -------------------------------------------------------------------

class PUpdateLuaNumber : public ::google::protobuf::Message {
 public:
  PUpdateLuaNumber();
  virtual ~PUpdateLuaNumber();

  PUpdateLuaNumber(const PUpdateLuaNumber& from);

  inline PUpdateLuaNumber& operator=(const PUpdateLuaNumber& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PUpdateLuaNumber& default_instance();

  void Swap(PUpdateLuaNumber* other);

  // implements Message ----------------------------------------------

  PUpdateLuaNumber* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PUpdateLuaNumber& from);
  void MergeFrom(const PUpdateLuaNumber& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline double value() const;
  inline void set_value(double value);

  // @@protoc_insertion_point(class_scope:OnSite.PUpdateLuaNumber)
 private:
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PPacket_2eproto();
  friend void protobuf_AssignDesc_PPacket_2eproto();
  friend void protobuf_ShutdownFile_PPacket_2eproto();

  void InitAsDefaultInstance();
  static PUpdateLuaNumber* default_instance_;
};
// -------------------------------------------------------------------

class PUpdate : public ::google::protobuf::Message {
 public:
  PUpdate();
  virtual ~PUpdate();

  PUpdate(const PUpdate& from);

  inline PUpdate& operator=(const PUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PUpdate& default_instance();

  void Swap(PUpdate* other);

  // implements Message ----------------------------------------------

  PUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PUpdate& from);
  void MergeFrom(const PUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .OnSite.PUpdateType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::OnSite::PUpdateType type() const;
  inline void set_type(::OnSite::PUpdateType value);

  // optional .OnSite.PUpdateLuaNumber uNumber = 3;
  inline bool has_unumber() const;
  inline void clear_unumber();
  static const int kUNumberFieldNumber = 3;
  inline const ::OnSite::PUpdateLuaNumber& unumber() const;
  inline ::OnSite::PUpdateLuaNumber* mutable_unumber();
  inline ::OnSite::PUpdateLuaNumber* release_unumber();
  inline void set_allocated_unumber(::OnSite::PUpdateLuaNumber* unumber);

  // optional .OnSite.PUpdateLuaString uString = 4;
  inline bool has_ustring() const;
  inline void clear_ustring();
  static const int kUStringFieldNumber = 4;
  inline const ::OnSite::PUpdateLuaString& ustring() const;
  inline ::OnSite::PUpdateLuaString* mutable_ustring();
  inline ::OnSite::PUpdateLuaString* release_ustring();
  inline void set_allocated_ustring(::OnSite::PUpdateLuaString* ustring);

  // optional .OnSite.PUpdateLuaBoolean uBoolean = 5;
  inline bool has_uboolean() const;
  inline void clear_uboolean();
  static const int kUBooleanFieldNumber = 5;
  inline const ::OnSite::PUpdateLuaBoolean& uboolean() const;
  inline ::OnSite::PUpdateLuaBoolean* mutable_uboolean();
  inline ::OnSite::PUpdateLuaBoolean* release_uboolean();
  inline void set_allocated_uboolean(::OnSite::PUpdateLuaBoolean* uboolean);

  // @@protoc_insertion_point(class_scope:OnSite.PUpdate)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_unumber();
  inline void clear_has_unumber();
  inline void set_has_ustring();
  inline void clear_has_ustring();
  inline void set_has_uboolean();
  inline void clear_has_uboolean();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::OnSite::PUpdateLuaNumber* unumber_;
  ::OnSite::PUpdateLuaString* ustring_;
  ::OnSite::PUpdateLuaBoolean* uboolean_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_PPacket_2eproto();
  friend void protobuf_AssignDesc_PPacket_2eproto();
  friend void protobuf_ShutdownFile_PPacket_2eproto();

  void InitAsDefaultInstance();
  static PUpdate* default_instance_;
};
// -------------------------------------------------------------------

class PFilePart : public ::google::protobuf::Message {
 public:
  PFilePart();
  virtual ~PFilePart();

  PFilePart(const PFilePart& from);

  inline PFilePart& operator=(const PFilePart& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PFilePart& default_instance();

  void Swap(PFilePart* other);

  // implements Message ----------------------------------------------

  PFilePart* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PFilePart& from);
  void MergeFrom(const PFilePart& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:OnSite.PFilePart)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* filename_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_PPacket_2eproto();
  friend void protobuf_AssignDesc_PPacket_2eproto();
  friend void protobuf_ShutdownFile_PPacket_2eproto();

  void InitAsDefaultInstance();
  static PFilePart* default_instance_;
};
// -------------------------------------------------------------------

class PControl : public ::google::protobuf::Message {
 public:
  PControl();
  virtual ~PControl();

  PControl(const PControl& from);

  inline PControl& operator=(const PControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PControl& default_instance();

  void Swap(PControl* other);

  // implements Message ----------------------------------------------

  PControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PControl& from);
  void MergeFrom(const PControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .OnSite.PControlType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::OnSite::PControlType type() const;
  inline void set_type(::OnSite::PControlType value);

  // @@protoc_insertion_point(class_scope:OnSite.PControl)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_PPacket_2eproto();
  friend void protobuf_AssignDesc_PPacket_2eproto();
  friend void protobuf_ShutdownFile_PPacket_2eproto();

  void InitAsDefaultInstance();
  static PControl* default_instance_;
};
// -------------------------------------------------------------------

class PPacket : public ::google::protobuf::Message {
 public:
  PPacket();
  virtual ~PPacket();

  PPacket(const PPacket& from);

  inline PPacket& operator=(const PPacket& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PPacket& default_instance();

  void Swap(PPacket* other);

  // implements Message ----------------------------------------------

  PPacket* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PPacket& from);
  void MergeFrom(const PPacket& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .OnSite.PPacketType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::OnSite::PPacketType type() const;
  inline void set_type(::OnSite::PPacketType value);

  // optional .OnSite.PUpdate uData = 2;
  inline bool has_udata() const;
  inline void clear_udata();
  static const int kUDataFieldNumber = 2;
  inline const ::OnSite::PUpdate& udata() const;
  inline ::OnSite::PUpdate* mutable_udata();
  inline ::OnSite::PUpdate* release_udata();
  inline void set_allocated_udata(::OnSite::PUpdate* udata);

  // optional .OnSite.PFilePart fpData = 3;
  inline bool has_fpdata() const;
  inline void clear_fpdata();
  static const int kFpDataFieldNumber = 3;
  inline const ::OnSite::PFilePart& fpdata() const;
  inline ::OnSite::PFilePart* mutable_fpdata();
  inline ::OnSite::PFilePart* release_fpdata();
  inline void set_allocated_fpdata(::OnSite::PFilePart* fpdata);

  // optional .OnSite.PControl cData = 4;
  inline bool has_cdata() const;
  inline void clear_cdata();
  static const int kCDataFieldNumber = 4;
  inline const ::OnSite::PControl& cdata() const;
  inline ::OnSite::PControl* mutable_cdata();
  inline ::OnSite::PControl* release_cdata();
  inline void set_allocated_cdata(::OnSite::PControl* cdata);

  // @@protoc_insertion_point(class_scope:OnSite.PPacket)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_udata();
  inline void clear_has_udata();
  inline void set_has_fpdata();
  inline void clear_has_fpdata();
  inline void set_has_cdata();
  inline void clear_has_cdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::OnSite::PUpdate* udata_;
  ::OnSite::PFilePart* fpdata_;
  ::OnSite::PControl* cdata_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_PPacket_2eproto();
  friend void protobuf_AssignDesc_PPacket_2eproto();
  friend void protobuf_ShutdownFile_PPacket_2eproto();

  void InitAsDefaultInstance();
  static PPacket* default_instance_;
};
// ===================================================================


// ===================================================================

// PUpdateLuaString

// required string value = 1;
inline bool PUpdateLuaString::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PUpdateLuaString::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PUpdateLuaString::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PUpdateLuaString::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& PUpdateLuaString::value() const {
  return *value_;
}
inline void PUpdateLuaString::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void PUpdateLuaString::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void PUpdateLuaString::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PUpdateLuaString::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* PUpdateLuaString::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PUpdateLuaString::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PUpdateLuaBoolean

// required bool value = 1;
inline bool PUpdateLuaBoolean::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PUpdateLuaBoolean::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PUpdateLuaBoolean::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PUpdateLuaBoolean::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool PUpdateLuaBoolean::value() const {
  return value_;
}
inline void PUpdateLuaBoolean::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// PUpdateLuaNumber

// required double value = 1;
inline bool PUpdateLuaNumber::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PUpdateLuaNumber::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PUpdateLuaNumber::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PUpdateLuaNumber::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double PUpdateLuaNumber::value() const {
  return value_;
}
inline void PUpdateLuaNumber::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// PUpdate

// required string name = 1;
inline bool PUpdate::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PUpdate::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PUpdate::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PUpdate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PUpdate::name() const {
  return *name_;
}
inline void PUpdate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PUpdate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PUpdate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PUpdate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PUpdate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PUpdate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .OnSite.PUpdateType type = 2;
inline bool PUpdate::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PUpdate::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PUpdate::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PUpdate::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::OnSite::PUpdateType PUpdate::type() const {
  return static_cast< ::OnSite::PUpdateType >(type_);
}
inline void PUpdate::set_type(::OnSite::PUpdateType value) {
  assert(::OnSite::PUpdateType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .OnSite.PUpdateLuaNumber uNumber = 3;
inline bool PUpdate::has_unumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PUpdate::set_has_unumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PUpdate::clear_has_unumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PUpdate::clear_unumber() {
  if (unumber_ != NULL) unumber_->::OnSite::PUpdateLuaNumber::Clear();
  clear_has_unumber();
}
inline const ::OnSite::PUpdateLuaNumber& PUpdate::unumber() const {
  return unumber_ != NULL ? *unumber_ : *default_instance_->unumber_;
}
inline ::OnSite::PUpdateLuaNumber* PUpdate::mutable_unumber() {
  set_has_unumber();
  if (unumber_ == NULL) unumber_ = new ::OnSite::PUpdateLuaNumber;
  return unumber_;
}
inline ::OnSite::PUpdateLuaNumber* PUpdate::release_unumber() {
  clear_has_unumber();
  ::OnSite::PUpdateLuaNumber* temp = unumber_;
  unumber_ = NULL;
  return temp;
}
inline void PUpdate::set_allocated_unumber(::OnSite::PUpdateLuaNumber* unumber) {
  delete unumber_;
  unumber_ = unumber;
  if (unumber) {
    set_has_unumber();
  } else {
    clear_has_unumber();
  }
}

// optional .OnSite.PUpdateLuaString uString = 4;
inline bool PUpdate::has_ustring() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PUpdate::set_has_ustring() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PUpdate::clear_has_ustring() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PUpdate::clear_ustring() {
  if (ustring_ != NULL) ustring_->::OnSite::PUpdateLuaString::Clear();
  clear_has_ustring();
}
inline const ::OnSite::PUpdateLuaString& PUpdate::ustring() const {
  return ustring_ != NULL ? *ustring_ : *default_instance_->ustring_;
}
inline ::OnSite::PUpdateLuaString* PUpdate::mutable_ustring() {
  set_has_ustring();
  if (ustring_ == NULL) ustring_ = new ::OnSite::PUpdateLuaString;
  return ustring_;
}
inline ::OnSite::PUpdateLuaString* PUpdate::release_ustring() {
  clear_has_ustring();
  ::OnSite::PUpdateLuaString* temp = ustring_;
  ustring_ = NULL;
  return temp;
}
inline void PUpdate::set_allocated_ustring(::OnSite::PUpdateLuaString* ustring) {
  delete ustring_;
  ustring_ = ustring;
  if (ustring) {
    set_has_ustring();
  } else {
    clear_has_ustring();
  }
}

// optional .OnSite.PUpdateLuaBoolean uBoolean = 5;
inline bool PUpdate::has_uboolean() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PUpdate::set_has_uboolean() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PUpdate::clear_has_uboolean() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PUpdate::clear_uboolean() {
  if (uboolean_ != NULL) uboolean_->::OnSite::PUpdateLuaBoolean::Clear();
  clear_has_uboolean();
}
inline const ::OnSite::PUpdateLuaBoolean& PUpdate::uboolean() const {
  return uboolean_ != NULL ? *uboolean_ : *default_instance_->uboolean_;
}
inline ::OnSite::PUpdateLuaBoolean* PUpdate::mutable_uboolean() {
  set_has_uboolean();
  if (uboolean_ == NULL) uboolean_ = new ::OnSite::PUpdateLuaBoolean;
  return uboolean_;
}
inline ::OnSite::PUpdateLuaBoolean* PUpdate::release_uboolean() {
  clear_has_uboolean();
  ::OnSite::PUpdateLuaBoolean* temp = uboolean_;
  uboolean_ = NULL;
  return temp;
}
inline void PUpdate::set_allocated_uboolean(::OnSite::PUpdateLuaBoolean* uboolean) {
  delete uboolean_;
  uboolean_ = uboolean;
  if (uboolean) {
    set_has_uboolean();
  } else {
    clear_has_uboolean();
  }
}

// -------------------------------------------------------------------

// PFilePart

// required string filename = 1;
inline bool PFilePart::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PFilePart::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PFilePart::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PFilePart::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& PFilePart::filename() const {
  return *filename_;
}
inline void PFilePart::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PFilePart::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void PFilePart::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PFilePart::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* PFilePart::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PFilePart::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bytes data = 2;
inline bool PFilePart::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PFilePart::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PFilePart::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PFilePart::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PFilePart::data() const {
  return *data_;
}
inline void PFilePart::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PFilePart::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PFilePart::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PFilePart::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* PFilePart::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PFilePart::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PControl

// required .OnSite.PControlType type = 1;
inline bool PControl::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PControl::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PControl::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PControl::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::OnSite::PControlType PControl::type() const {
  return static_cast< ::OnSite::PControlType >(type_);
}
inline void PControl::set_type(::OnSite::PControlType value) {
  assert(::OnSite::PControlType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// PPacket

// required .OnSite.PPacketType type = 1;
inline bool PPacket::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PPacket::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PPacket::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PPacket::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::OnSite::PPacketType PPacket::type() const {
  return static_cast< ::OnSite::PPacketType >(type_);
}
inline void PPacket::set_type(::OnSite::PPacketType value) {
  assert(::OnSite::PPacketType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .OnSite.PUpdate uData = 2;
inline bool PPacket::has_udata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PPacket::set_has_udata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PPacket::clear_has_udata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PPacket::clear_udata() {
  if (udata_ != NULL) udata_->::OnSite::PUpdate::Clear();
  clear_has_udata();
}
inline const ::OnSite::PUpdate& PPacket::udata() const {
  return udata_ != NULL ? *udata_ : *default_instance_->udata_;
}
inline ::OnSite::PUpdate* PPacket::mutable_udata() {
  set_has_udata();
  if (udata_ == NULL) udata_ = new ::OnSite::PUpdate;
  return udata_;
}
inline ::OnSite::PUpdate* PPacket::release_udata() {
  clear_has_udata();
  ::OnSite::PUpdate* temp = udata_;
  udata_ = NULL;
  return temp;
}
inline void PPacket::set_allocated_udata(::OnSite::PUpdate* udata) {
  delete udata_;
  udata_ = udata;
  if (udata) {
    set_has_udata();
  } else {
    clear_has_udata();
  }
}

// optional .OnSite.PFilePart fpData = 3;
inline bool PPacket::has_fpdata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PPacket::set_has_fpdata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PPacket::clear_has_fpdata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PPacket::clear_fpdata() {
  if (fpdata_ != NULL) fpdata_->::OnSite::PFilePart::Clear();
  clear_has_fpdata();
}
inline const ::OnSite::PFilePart& PPacket::fpdata() const {
  return fpdata_ != NULL ? *fpdata_ : *default_instance_->fpdata_;
}
inline ::OnSite::PFilePart* PPacket::mutable_fpdata() {
  set_has_fpdata();
  if (fpdata_ == NULL) fpdata_ = new ::OnSite::PFilePart;
  return fpdata_;
}
inline ::OnSite::PFilePart* PPacket::release_fpdata() {
  clear_has_fpdata();
  ::OnSite::PFilePart* temp = fpdata_;
  fpdata_ = NULL;
  return temp;
}
inline void PPacket::set_allocated_fpdata(::OnSite::PFilePart* fpdata) {
  delete fpdata_;
  fpdata_ = fpdata;
  if (fpdata) {
    set_has_fpdata();
  } else {
    clear_has_fpdata();
  }
}

// optional .OnSite.PControl cData = 4;
inline bool PPacket::has_cdata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PPacket::set_has_cdata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PPacket::clear_has_cdata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PPacket::clear_cdata() {
  if (cdata_ != NULL) cdata_->::OnSite::PControl::Clear();
  clear_has_cdata();
}
inline const ::OnSite::PControl& PPacket::cdata() const {
  return cdata_ != NULL ? *cdata_ : *default_instance_->cdata_;
}
inline ::OnSite::PControl* PPacket::mutable_cdata() {
  set_has_cdata();
  if (cdata_ == NULL) cdata_ = new ::OnSite::PControl;
  return cdata_;
}
inline ::OnSite::PControl* PPacket::release_cdata() {
  clear_has_cdata();
  ::OnSite::PControl* temp = cdata_;
  cdata_ = NULL;
  return temp;
}
inline void PPacket::set_allocated_cdata(::OnSite::PControl* cdata) {
  delete cdata_;
  cdata_ = cdata;
  if (cdata) {
    set_has_cdata();
  } else {
    clear_has_cdata();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace OnSite

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OnSite::PUpdateType>() {
  return ::OnSite::PUpdateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OnSite::PPacketType>() {
  return ::OnSite::PPacketType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OnSite::PControlType>() {
  return ::OnSite::PControlType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_PPacket_2eproto__INCLUDED
